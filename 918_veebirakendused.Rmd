# Veebirakendused, veebimajutus {#veebirakendused}

Tavalised arvutis hoitavad kaardid on **digitaalsed kaardid**, mille võib panna ka veebilehele, ent mille koostamine, säilitamine ja näitamine ei sõltu kuidagi veebitehnoloogiast. Digitaalsed kaardid on staatilised. **Veebikaardid** aga mitte lihtsalt ei paikne veebis, vaid on veebist sõltuvad: nii nende koostamine kui ka vaatamine sõltub veebitehnoloogiast. Sageli on veebikaardid dünaamilised, interaktiivsed ning võivad kasutada ka mujalt veebist päritavaid andmeid.

Lisaks sellele, et veebikaartidel saab kuvada korraga mitut kihti, mingeid kihte sisse ja välja lülitada või kasutada andmete esitamiseks animatsiooni, saab nendele lisada ka erinevaid lisaelemente, näiteks sisse- ja väljasuumimine, vahemaade mõõtmine, legend, pealkirjad, otsing jpm. Samuti saab määrata, mis juhtub, kui kasutaja liigub hiirega mingi punkti peale, sellel klikib või mingil muul moel veebikaardiga suhtleb.  

Tänapäevase veebikaardi aluskaart koosneb **paanidest** (*tiles*), tüüpiliselt 256×256 piksli suurustest rasterpiltidest (aga juba kasutatakse ka resolutsioonist sõltumatuid vektorpaane), mida laaditakse vastavalt kasutaja valikutele kaardipaanide serverist (näiteks OpenStreetMapi serverist). See tähendab, et kasutajale näidatakse ainult seda osa kaardist, mida tal on vaja näha, muutes kaardi laadimise oluliselt kiiremaks.  

```{r tiles, echo=F, fig.show='hold', fig.align='center', out.width= "70%", fig.cap= "Kaardipaanide laadimine (Allikas: [Axis Maps](https://www.axismaps.com/guide/what-is-a-web-map))"}
knitr::include_graphics(here::here("imgs", "18_tiles.gif"))
```

Aluskaart annab veebikaardile geograafilise konteksti, ent ei ole iseenesest kaardi tegemise ega vaatamise põhjuseks. Aluskaardil saab omakorda kuvada muid vektor- või rasterandmeid.

Suur osa veebikaartidest (ja neid pakkuvatest APIdest ehk rakendusliidestest) on vaikimisi **Web Mercatori** projektsioonis (CRS-iga EPSG:3857), mille puhul peab arvestama sellega, et alade suurus on moonutatud. 

<iframe width="100%" height="480px" src="https://thetruesize.com/#?borders=1~!MTU2MDMyNDc.NDgyOTAxOQ*MzM0ODE1MTM(NDAxMDYxNQ~!CONTIGUOUS_US*MTAwMjQwNzU.MjUwMjM1MTc(MTc1)MA~!IN*NTI2NDA1MQ.Nzg2MzQyMQ)Mg~!CN*OTkyMTY5Nw.NzMxNDcwNQ(MjI1)MQ" frameborder="0" scrolling="yes"></iframe>

Kui tahta teha sageli, palju või korralikke veebikaarte ja kaardirakendusi, tasub vähemalt mingil algtasemel ära õppida keel, milles seda teha saab. 
Veebilehed kasutavad (vähemalt) [**HTML**](https://www.w3schools.com/html/default.asp)i, et veebilehte struktureerida, [**CSS**](https://www.w3schools.com/css/default.asp)i, et veebilehte kujundada, ning [**JavaScript**](https://www.w3schools.com/js/default.asp)i, et lisada veebilehele interaktiivsust.
<!-- javascript võib lehe sisu muuta, muuta selle väljanägemist mingis brauseris, saata serverile mingit informatsiooni või küsida serverilt uut informatsiooni-->


```{r htmlcssjs, echo=F, fig.show='hold', fig.align='center', out.width= "50%", fig.cap= "HTML, JavaScript ja CSS (Allikas: [dev.to](https://dev.to/fabcodingzest/how-to-get-started-with-web-development-front-end-part-1-5c6h))"}
knitr::include_graphics(here::here("imgs", "18_htmlcssjs.jpg"))
```

Ühe lihtsa veebilehe struktuur HTML-failis võib välja näha näiteks selline: 

```
<!DOCTYPE html>
<html>
  <head>
    <title>Minu lehe pealkiri</title>
    <link href="stiil.css" type="text/css" rel="stylesheet">
  </head>
  <body bgcolor="black" text="white">
    <h1>Minu esimene veebileht</h1>
    <p>Siin on mingi tekst.</p>
	<p>Siin on <a href="https://tartugeohum.github.io/" target="_blank">link</a>, kust leiab kõik selle kursuse materjalid</p>
    <p>Siin all on nupp, millele vajutades saab veel midagi teada.</p>
    <button type="button" onclick="document.getElementById('pealkiri').style.display='block'">Vajuta siia!</button>
    <p id="pealkiri" style="display:none">See on minu esimene veebileht!</p>
  </body>
</html>
```

Selle veebilehe juurde käiv CSS-fail omakorda selline:

```
h1{
  text-align: center;
  color: blue;
  font-size: 40px;
}
p{
  font-family: courier;
  font-size: 20px;
}
```

Kokku saab ühe väga lihtsa lehe, mis näeb välja selline:

```{r html, echo=F, fig.show='hold', fig.align='center', out.width= "80%", fig.cap= "Lihtne veebileht"}
knitr::include_graphics(here::here("imgs", "18_html.PNG"))
```

Interaktiivsete **veebikaartide** jaoks kasutatakse sageli näiteks JavaScripti teekide/pakettide [**Leaflet**](https://leafletjs.com/)i või [**OpenLayers**](https://openlayers.org/)i APIsid ehk rakendusliideseid, mis suhtlevad erinevate serveritega ning muudavad ja kuvavad kaarti vastavalt kasutaja valikutele. Mõlemad teegid on vabavaralised ja avatud lähtekoodiga, samas kui näiteks Google Mapsi API ja ArcGISi API on seotud konkreetse omandusliku (*proprietary*) tarkvaraga. 
<!-- Veebikaartide APId sisaldavad kaardiklasse ja kihte, ilma et peaks ise kirjutama tervet pikka koodi, millega mingit kaarti programmaatiliselt joonistada. APIde abil saab seega kirjutada programme kiiremini ja lihtsamalt -->

```{r leafletOL, echo=F, fig.show='hold', fig.align='center', out.width= "28%", fig.cap= "Leaflet ja OpenLayers"}
knitr::include_graphics(here::here("imgs", c("18_leaflet.png", "18_openlayers.png")))
```


Leafleti kasutatakse üldiselt rohkem, see on ökonoomsem, lihtsama APIga ning sobib hästi lihtsamate kaardirakenduste tegemiseks (*Leaflet does the 20% of things that are required 80% of the time*). Samas saab paljud funktsioonid kätte ainult erinevatest pluginatest ning kõiki võib-olla ei olegi veel olemas. Suure hulga funktsionaalsustega kaardirakenduste jaoks soovitatakse kasutada pigem OpenLayersit, mille API on keerulisem, ent selle võrra on see paindlikum ning pakub rohkem funktsioone. 

Ka Mapbox pakub oma JavaScripti teeki/paketti **[Mapbox GL JS](https://docs.mapbox.com/mapbox-gl-js/guides/)**, mis võimaldab koostada veebikaarte ja kaardirakendusi.  


## Kaardikihid QGISis

Eelmisel korral tegime kaardid, kus interpoleerisime **murdeatlase levikuandmete** ja **murdekorpuse sagedusandmete** põhjalt *ei ole* ja *pole* rasterkihid, kus teadaolevate andmepunktide keelendi väärtuste järgi ennustasime ka vahepealseid väärtusi kohtadesse, kust andmeid ei olnud.  

Kuvame neid rasterkihte veebikaardil. Lisaks anname veebikaardi kasutajale võimaluse vaadata eraldi atlase ja korpuse punktandmeid ning kihelkondade vektorkihti.

Selleks, et kihtide loomine kiiremini läheks, on juba tekitatud sobivad vektorkihid __*atlas.gpkg*__, __*korpus.gpkg*__ ja __*kihelkonnad.gpkg*__, mida pole vaja enam filtreerida ega muude andmetega ühendada. 

- Laadime kihid QGISi,  
- värvime atlase punktid vastavalt sellele, kas punkt esindab *ei ole* või *pole* varianti (*Categorized*),  
- värvime korpuse punktid vastavalt sellele, kui suur on *ei ole* osakaal (*Graduated*),  
- määrame atlase ja korpuse punktidele erinevad sümbolid.  


Järgmiseks teeme **rasterkihid** *Thin Plate Spline* meetodiga, et ennustada *ei ole* (*vs.* *pole*) väärtusi ka nendele aladele, kust atlases või korpuses andmeid ei ole.  

- *Processing → Toolbox → Thin Plate Spline*  
- Kasutame atlase punktikihi `KeelendNum` tulpa, kus on ainult väärtused 0 ja 1, ja korpuse punktikihi `eiole` tulpa, kus on väärtused 0st 1ni. Rasterkihtidel niisiis ennustame väärtusi 0 ja 1 vahepeale (tegelikult ka üle ja alla nende).  
- Määrame piksli suuruseks 500 ja *Regularisation* väärtuseks 0.1, otsinguraadiuseks 20 km (20 000 meetrit).  
- Lõikame rastrid kihelkondade kihi järgi.   
- Värvime rastrid nii, et alad, mis on *pole*-lembesemad, on tumedamad. Määrame skaala otspunktideks 0 ja 1.    
- Nimetame lõigatud ja värvitud rastrid nt nimedega *atlase TPS* ja *korpuse TPS*.  



## Veebikaartide tegemine

**Peidame** vektorkihtidelt tunnused, mida me ei taha veebikaardil näidata. Selleks teeme igal kihil topeltkliki, liigume jaotisesse *Attributes Form*, valime peidetava atribuudi ja *Widget Type* alt valime *Hidden*. Võiksime peita vähemalt objekte identifitseeriva atribuudi `fid`, lisaks ka nt kihelkondade lühendid jms.  

Järgmiseks valime kaardile **aluskaardi** (*QuickMapServices*) ja muudame projekti CRSi EPSG:3857ks. **Salvestame projekti ja rasterfailid**!   

Tehtud kaartide hõlpsaks lisamiseks veebi saab installida nüüd **qgis2web** pistikprogrammi. See genereerib QGISi projektist kas OpenLayersi, Leafleti või Mapboxi API abil veebikaardi tervikliku veebilehena koos kõikide vajalike kaustade ja failidega, ilma et peaksime tingimata ise JavaScriptis, CSSis ja HTMLis koodi kirjutama. 

Valime seejärel *Web → qgis2web → Create web map*.  

Jaotises `Layers and Groups` valime, milliseid kihte oma veebikaardil tahame näidata.  

- Iga kihi juures saab omakorda valida, kas tahame, et kiht oleks kohe kaarti avades nähtav (*Visible*), kas kihi elementidel klikkides avaneksid hüpikaknad (*Popups*) ja kas soovime, et väiksemal mõõtkaval oleksid lähedased punktid klasterdatud ühe punkti alla, nii et oleks nähtav, kui mitu punkti sellesse piirkonda jääb (*Cluster*, ainult vektorkihtidel).  
- Hüpikakende puhul (*Popup fields*) saab omakorda igale andmestiku tunnusele määrata, kas lisada sellele ka tulbanimi ja kui, siis kas tulbas oleva teksti kõrvale (*inline label*) või kohale (*header label*).

```{r layersandgroups, echo=F, fig.show='hold', fig.align='center', out.width= "90%", fig.cap= "Kihtide ja nende atribuutide kuvamine QGISi qgis2web pistikprogrammis"}
knitr::include_graphics(here::here("imgs", "18_layersandgroups.png"))
```

Jaotises `Appearance` valime, milliseid üldisi elemente ja vidinaid oma kaardile soovime lisada. Näiteks:

- *Add layers list* alt saab valida, kas võimalikud kihid kuvada menüüs, mille saab lahti klõpsata (*Collapsed*), või menüüs, kus on kõik kihid kohe nähtaval (*Expanded*).  
- *Attribute filter* kastis saab valida need andmestiku atribuudid, mille põhjal kaardi kasutaja saab alamhulki pärida, nt kui tahab näha ainult Võru murde andmeid või ainult *ei ole* punkte.   
- *Layer search* alt saab määrata kihid, millelt kasutaja võib päringuid teha (nt et leida üles mõni Pühalepa kihelkonna punktike).  
- *Template* ütleb, kas kaardi suurus veebilehel on nii suur, kui ta on parajasti näha QGISi peaaknas, nn lõuendil (*canvas*), või ulatub kaart üle kogu veebilehe.  
- *Extent* määrab ära, kas näeme veebikaardi avamisel seda vaadet, mida parajasti QGISi peaaknas lõuendil, või näidatakse sellist ulatust, mis katab ära kihtide maksimaalse ulatuse (nt et kõik punktid kaardil oleksid kohe alguses näha).  
- *Max zoom level* ja *Min zoom level* määravad ära, kui detailselt (mis suumimise astmel) kasutajal kaarti vaadata lubame.  

```{r appearance, echo=F, fig.show='hold', fig.align='center', out.width= "100%", fig.cap= "Interaktiivsete võimaluste lisamine"}
knitr::include_graphics(here::here("imgs", "18_appearance.png"))
```

Jaotises `Export` saame määrata ära, kuhu veebikaardi väljundi saadame: kas mingisse lokaalsesse kausta oma arvutis või otse FTP serverisse. Paneme väljundi esialgu oma kursuse kausta. Vajutame *Export*.  

Lähemalt saab qgis2web pistikprogrammist lugeda jaotisest `Help`.  


## Ülesanne

Salvestame olemasoleva QGISi projekti ja teeme seejärel uue projekti. Laadime sinna andmestiku *notable_estonians.gpkg*. See on veidi puhastatud versioon juba [12. praktikumis](#yl12_1) kasutatud andmestikust tuntud eestlaste või Eestiga seotud isikute kohta, mis on aluseks rakendusele [Notable people](https://tjukanovt.github.io/notable-people?fbclid=IwAR0PPqeqBJNJGXMMQ0avraSaSOwm05xIxouUWhiLbeQ1Te9gBVnvwGC3i3U) (punktid). Terve andmestiku viide ja allalaadimise link [siin](https://data.sciencespo.fr/dataset.xhtml?persistentId=doi:10.21410/7E4/RDAG3O), andmestiku tutvustus [siin](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC9184645/). 

Kujundame punktid.  

Teeme rakenduse, kus tuntud eestlaste punkte saaks kõikide tunnuste järgi filtreerida ja punktile liikudes saaks konkreetse isiku kohta rohkem infot. Lisaks võiks saada teha päringuid konkreetsete nimede põhjal.  

Ekspordime veebikaardi Leafleti APIt kasutades. Nimetame väljundkausta ümber nimega **kuulsad_eestlased**.    

## Veebikaartide majutamine ja jagamine

Valmis veebikaardi jagamiseks teistega võid saata kogu rakenduse kausta kellelegi lokaalselt vaatamiseks või selle kuskile serverisse avalikult üles panna. 


### Ülikooli võrguketas

Tartu Ülikooli tudengitel ja töötajatel on TÜ serveris \\\\pohl.ut.ee oma võrguketas (vaikimisi 1GB), kus on võimalik hoida ja varundada oma isiklikke faile. Samuti saab TÜ serverisse oma kodukataloogi salvestada ja üles panna loodud veebilehed. Veebilehed tuleks salvestada kodukataloogi alamkausta **public_html** ning nendele saab ligi aadressilt **`https://kodu.ut.ee/~kasutajanimi/`**.  

Ülikooli võrguketastele ligipääsemiseks peab olema ülikooli sisevõrgus. Väljastpoolt ülikooli saab sisevõrku turvaliselt ühenduse [virtuaalse privaatvõrgu](https://wiki.ut.ee/pages/viewpage.action?pageId=17105590) (**VPN**) abil. 

Ülikooli sisevõrgus olles saab isikliku võrguketta kodu- või sülearvutile [külge haakida](https://wiki.ut.ee/pages/viewpage.action?pageId=17105488). Windowsis näiteks tuleb selleks minna esmalt jaotisesse *This PC* ja valida ülamenüüst *Computer → Map network drive*. Vali võrgukettale suvaline täht, mis pole veel kasutuses, *Folder* jaotisse kirjuta `\\pohl.ut.ee\sinukasutajanimi`. NB! Kui sisselogimisel küsitakse kasutajanime, siis see olgu kujul `domenis\\kasutajanimi` (mitte `kasutajanimi@ut.ee`)
 
(Kui see kohe ei tööta, siis proovi esmalt [seda](https://www.techcrumble.net/2018/03/you-cant-access-this-shared-folder-because-your-organizations-security-policies-block-unauthenticated-guest-access/).)

Kui liigutad nüüd kogu qgis2web väljundi kausta (kas kausta *kuulsad_eestlased* või *ei ole/pole* veebirakenduse) oma kursuse kaustast külge haagitud võrgukettale *public_html* kausta ja kirjutad seejärel mõne veebibrauseri aadressiribale `https://kodu.ut.ee/~sinukasutajanimi/rakendusekaustanimi`, peaksid nägema oma veebikaarti kõigile kättesaadaval kujul.  


### GitHub Pages

Veebikaarte saab tasuta majutada näiteks ka [**GitHubis**](https://github.com/) (vaata lühikest juhendit [siit](https://rogerdudler.github.io/git-guide/)). Selleks tuleks teha uus avalik repositoorium, kuhu paigutada *qgis2web*i väljundkausta sisu (sh kindlasti ka fail *index.html*). Vaata juhendit näiteks [siit](https://github.com/NieneB/Webmapping_for_beginners/wiki/Hosting-on-github). 

Tee endale GitHubi konto ning seal loo uus repositoorium (*New*), nt kas üldisema nimega *veebikaart* või spetsiifilisema nimega.    

```{r loouuskonto, echo=F, fig.show='hold', fig.align='center', out.width= "70%", fig.cap= "Uue repositooriumi tegemine GitHubis"}
knitr::include_graphics(here::here("imgs", "18_loouuskonto.png"))
```


Kõige lihtsam on GitHubis toimetada [GitHub Desktopi](https://desktop.github.com/) rakenduse abil. 

- Laadi programm alla.  
- Ava programm.  
- Vali *File → Options → Accounts* ning logi sisse GitHub.com kontole oma GitHubi kasutajanime ja parooliga (võib toimuda läbi brauseri).  
- Järgmiseks vali avalehel *Clone a repository from the Internet* ning filtreeri välja veebis loodud repositoorium (nt *MPilvik/veebikaart*). Vali see, vali oma arvutis koht, kus tahad seda kausta lokaalselt enda arvutis hoida, ning vajuta *Clone*. Nüüd tekib sinu arvutis vastavasse kausta uus tühi kaust.  
- Sikuta sellesse tühja kausta kogu qgis2web pistikprogrammi eksporditud väljundkausta **sisu** (NB! ainult sisu, mitte kausta ennast).  
- Mine tagasi GitHub Desktopi rakendusse. Näed, et rakendus näitab sulle kaustas toimunud muudatusi (lisamisi, kustutamisi, muid muudatusi).  
- Selleks, et veebikaardi materjale nüüd GitHubi üles lükata, tuleb need n-ö *commit*'ida ning seejärel *push*'ida. All vasakus nurgas on kastike koos nupuga *Commit to main*. Lisa *Summary* väljale mingi kirjeldus, mis uuendusi üles laadid (nt *veebikaardi materjalid*) ning vajuta *Commit to main* nupule.  
- Lõpuks pead vajutama *Publish branch/Push origin* nupule, et kõik veebi üles laadida.  
- Lehel github.com peaksid nüüd sisse logides nägema, et qgis2webi väljundid (sh index.html) on kõik loodud veebikaardi kaustas. 


```{r github1, echo=F, fig.show='hold', fig.align='center', out.width= "70%", fig.cap= "Üleslaaditud veebikaardi materjalid GitHubis"}
knitr::include_graphics(here::here("imgs", "18_github1.png"))
```

- Lõpuks tuleb veebileht ka rakendusena nähtavaks teha. Selleks saab kasutada **GitHub Pages** veebimajutuse teenust. Vali oma repositooriumis *Settings → Pages → Branch* = *main* ja vajuta *Save*. Oota paar sekundit ning mine lehele `https://sinukasutajanimi.github.io/sinurakendusenimi/`

Kui tahad veebikaardi repositooriumit ära kustutada, saad teha seda kaustas *Settings → General → Danger Zone → Delete this repository* alt.  

Kuskile serverisse riputatud veebilehte saab omakorda paigutada teise veebilehe sisse, nt HTML-i [**iframe**](https://www.w3schools.com/tags/tag_iframe.ASP)-märgendi abil. 


## Järgmisel korral

Jätkame veebirakenduste teemaga ja proovime teha valmis ühe veebirakenduse päris nullist.  
